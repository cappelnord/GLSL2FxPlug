# Part of GLSL2FxPlug
# https://github.com/cappelnord/GLSL2FxPlug

import re
import time

from utils import VERSION

DEBUG = False

def clamp(x, min_value, max_value):
	return min(max(x, min_value), max_value)

def assure_minmax_order(v, min_key, max_key):
	if v[min_key] > v[max_key]:
		temp = v[min_key]
		v[min_key] = v[max_key]
		v[max_key] = temp

def next_param_id(obj):
	ret = 1000
	for pair in obj["param_ids"]:
		if pair[1] >= ret:
			ret = pair[1] + 1
	return ret

def add_param_id(obj, name, id):
	obj["param_ids"].append([name, id])

def param_id_name(name):
	return "k" + name + "ParamID"

def in_list_or_default(list, index, default):
	if len(list) > index:
		return list[index]
	else:
		return default

def valid_var_name(s):
	if s == "" or (not s):
		return False

	return re.match("^[a-zA-Z_][a-zA-Z0-9_]*$", s) != None

def validate_var_name(s, obj):
	valid = valid_var_name(s)
	if not valid:
		raise Exception("Variable name \"%s\" invalid!"%(s))

	return valid

def multiline_c_string(s):
	s = s.strip()
	s = s.replace("\"", "\\\"")
	lines = s.split("\n")
	ret = "\"" + lines[0]
	for line in lines[1:]:
		ret = ret + "\\\n" + line
	ret = ret + "\""
	return ret

def generate_header_code(obj):
	obj["code"]["HEADER"] = """
/*
    Generated by GLSL2FxPlug Version %(version)s on %(date)s.
    https://github.com/cappelnord/GLSL2FxPlug

    Code adapted from and inspired by the GLSLFxPlug Example in the FxPlug SDK.
*/

"""%{"version": VERSION, "date": time.strftime("%Y/%m/%d")}

def generate_shader_code(obj):
	obj["code"]["SHADER_SOURCE"] = (
	"const char *vertexSource = " + multiline_c_string(obj["vertex_string"]) + ";\n" +
	"const char *fragmentSource = " + multiline_c_string(obj["fragment_string"]) + ";\n"
	)

def generate_paramid_code(obj):
	s = ""
	if len(obj["param_ids"]) > 0:
		s = s + "enum {\n"
		for pair in obj["param_ids"]:
			s = s + "    " + pair[0] + " = " + str(pair[1]) + ",\n"
		s = s + "};\n"

	obj["code"]["PARAMETER_IDS"] = s

def attach_to_scrap(obj, s):
	obj[obj["current_scrap"]] = obj[obj["current_scrap"]] + s

def attach_to_code(obj, where, s):
	obj["code"][where] = obj["code"][where] + s

def attach_float_uniform(obj, var_name, what):
	attach_to_scrap(obj, "uniform float %s;\n"%(var_name))
	attach_to_code(obj, "SET_UNIFORMS", "glUniform1f(glGetUniformLocation(_program_object, \"%s\"), %s);\n"%(var_name, what))

def attach_vec2_uniform(obj, var_name, what1, what2):
	attach_to_scrap(obj, "uniform vec2 %s;\n"%(var_name))
	attach_to_code(obj, "SET_UNIFORMS", "glUniform2f(glGetUniformLocation(_program_object, \"%s\"), %s, %s);\n"%(var_name, what1, what2))

def attach_timing_api(obj):
	if not obj["has_timing_api"]:
		obj["has_timing_api"] = True
		obj["code"]["VARIES_OVER_TIME"] = "YES"
		attach_to_code(obj, "REQUEST_APIS", """		
id timingApi;
timingApi = [_apiManager apiForProtocol:@protocol(FxTimingAPI)];

double fps = (double) [timingApi timelineFpsNumeratorForEffect:self] / 
             (double) [timingApi timelineFpsDenominatorForEffect:self];""")

def parse_command_args(payload):
	ret = payload.split(",")
	for i in range(len(ret)):
		ret[i] = ret[i].strip()
	return ret

def prepare_parameter(obj, pl, num_args, prefix):
	v = {}
	v["var_name"] = 	 str(pl[0])
	v["name"] =          str(in_list_or_default(pl, num_args-2, v["var_name"]))
	v["param_id"] =      int(in_list_or_default(pl, num_args-1, next_param_id(obj)))

	v["c_name"] = prefix + "_" + v["var_name"]

	validate_var_name(v["var_name"], obj)

	v["param_name"] = param_id_name(v["var_name"])
	add_param_id(obj, v["param_name"], v["param_id"])
	
	return v

def switch_scrap(obj, what):
	if obj["has_open_subgroup"]:
		processor_endsubgroup(obj, None, None)
	obj["current_scrap"] = what
	obj[what] = ""

def processor_set_data(obj, cmd, pl):
	obj["info"][cmd] = pl[0]

def processor_set_classname(obj, cmd, pl):
	if not valid_var_name(pl[0]):
		raise "Invalid $CLASSNAME: Must be valid C variable name."
	processor_set_data(obj, cmd, pl)

def processor_set_vertex(obj, cmd, pl):
	switch_scrap(obj, "vertex_string")

def processor_set_fragment(obj, cmd, pl):
	switch_scrap(obj, "fragment_string")

def processor_check_version(obj, cmd, pl):
	if pl[0] != "1":
		raise Exception("Version mismatch!")

def processor_input(obj, cmd, pl):
	if obj["has_input_texture"]:
		raise Exception("Only one INPUT allowed!")

	obj["has_input_texture"] = True

	var_name = pl[0]

	validate_var_name(var_name, obj)

	v = {"var_name": var_name}

	attach_to_scrap(obj, "uniform sampler2DRect %(var_name)s;\n"%v)

	attach_to_code(obj, "BIND_TEXTURES", """
glActiveTexture(GL_TEXTURE0);
[inTex bind];
""")

	attach_to_code(obj, "SET_UNIFORMS", """
GLint inputTexLoc;
inputTexLoc = glGetUniformLocation(_program_object, "%(var_name)s");
glUniform1i(inputTexLoc, 0);
"""%v)

	attach_to_code(obj, "UNBIND_TEXTURES", """
glActiveTexture(GL_TEXTURE0);
[inTex disable];
glBindTexture ([inTex target], 0);
""")

	attach_vec2_uniform(obj, var_name + "_dim", "tWidth", "tHeight")

def __processor_time(obj, cmd, pl, what):
	var_name = pl[0]

	if not validate_var_name(var_name, obj): return

	attach_timing_api(obj)
	attach_float_uniform(obj, var_name, what + " /fps")
	attach_float_uniform(obj, var_name + "_frame", what)


# TIMING

def processor_time(obj, cmd, pl):
	__processor_time(obj, cmd, pl, "renderInfo.frame")

def processor_cliptime(obj, cmd, pl):
	__processor_time(obj, cmd, pl, "(renderInfo.frame - [timingApi startTimeForEffect:self])")

def processor_clipduration(obj, cmd, pl):
	__processor_time(obj, cmd, pl, "[timingApi durationForEffect:self]")

def processor_fps(obj, cmd, pl):
	var_name = pl[0]
	if not validate_var_name(var_name, obj): return

	attach_timing_api(obj)
	attach_float_uniform(obj, var_name, "fps")

def processor_scale(obj, cmd, pl):
	var_name = pl[0]
	if not validate_var_name(var_name, obj): return

	attach_vec2_uniform(obj, var_name, "renderInfo.scaleX", "renderInfo.scaleY")



# SUBGROUPS

def processor_subgroup(obj, cmd, pl):
	v =  prepare_parameter(obj, pl, 3, "subgroup")

	if obj["has_open_subgroup"]: 
		processor_endsubgroup(obj, None, None)

	obj["has_open_subgroup"] = True

	attach_to_code(obj, "PARAMETERS", """
[parmsApi startParameterSubGroup:@"%(name)s"
                          parmId:%(param_name)s
                       parmFlags:kFxParameterFlag_DEFAULT];
"""%v)

def processor_endsubgroup(obj, cmd, pl):
	if not obj["has_open_subgroup"]:
		raise Exception("ENDSUBGROUP has no open SUBGROUP")

	obj["has_open_subgroup"] = False

	attach_to_code(obj, "PARAMETERS", """[parmsApi endParameterSubGroup];
""")



# PARAMETERS

def processor_rgb(obj, cmd, pl):
	__processor_color(obj, cmd, pl, False)

def processor_rgba(obj, cmd, pl):
	__processor_color(obj, cmd, pl, True)

def __processor_color(obj, cmd, pl, alpha):
	num_args = 6
	if alpha: num_args = num_args + 1
	v = prepare_parameter(obj, pl, num_args, "color")

	v["default_r"] = float(in_list_or_default(pl, 1, 0.0))
	v["default_g"] = float(in_list_or_default(pl, 2, 0.0))
	v["default_b"] = float(in_list_or_default(pl, 3, 0.0))
	
	v["default_r"] = clamp(v["default_r"], 0, 1)
	v["default_g"] = clamp(v["default_g"], 0, 1)
	v["default_b"] = clamp(v["default_b"], 0, 1)

	v["gl_type"] = "vec3"
	v["set_uniform"] = "glUniform3f"

	v["alpha_parm"] = ""
	v["alpha_var"] = ""
	v["alpha_parm_retrieve"] = ""

	if alpha:
		v["default_a"] = float(in_list_or_default(pl, 4, 1.0))
		v["default_a"] = clamp(v["default_a"], 0, 1)

		v["gl_type"] = "vec4"
		v["set_uniform"] = "glUniform4f"

		v["alpha_parm"] = """
                       defaultAlpha:%(default_a)s\n"""%v
        
		v["alpha_var"] = ", %(c_name)s_a"%v
		v["alpha_parm_retrieve"] = "\nalphaValue:&%(c_name)s_a\n"%v
	
	attach_to_scrap(obj, "uniform %(gl_type)s %(var_name)s;\n"%v)

	attach_to_code(obj, "PARAMETERS", """
[parmsApi addColorParameterWithName:@"%(name)s"
                             parmId:%(param_name)s
                         defaultRed:%(default_r)f
                       defaultGreen:%(default_g)f
                        defaultBlue:%(default_b)f%(alpha_parm)s
                          parmFlags:kFxParameterFlag_DEFAULT];		
"""%v)

	attach_to_code(obj, "RETRIEVE_PARAMS", """
double %(c_name)s_r, %(c_name)s_g, 
       %(c_name)s_b%(alpha_var)s;

[parmsApi getRedValue:&%(c_name)s_r
           greenValue:&%(c_name)s_g
            blueValue:&%(c_name)s_b%(alpha_parm_retrieve)s
             fromParm:%(param_name)s
               atTime:renderInfo.frame];
"""%v)

	attach_to_code(obj, "SET_UNIFORMS", """
%(set_uniform)s(glGetUniformLocation(_program_object, "%(var_name)s"), %(c_name)s_r, %(c_name)s_g, %(c_name)s_b%(alpha_var)s);
"""%v)	


def processor_angle(obj, cmd, pl):
	v =  prepare_parameter(obj, pl, 6, "angle")

	v["rad_deg"] = 57.29577951308232

	v["default_value"] = float(in_list_or_default(pl, 1, 0.0))
	v["param_min"] =     float(in_list_or_default(pl, 2, 0.0)) / v["rad_deg"]
	v["param_max"] =     float(in_list_or_default(pl, 3, 360.0)) / v["rad_deg"]

	v["default_value"] = clamp(v["default_value"], v["param_min"], v["param_max"])

	assure_minmax_order(v, "param_min", "param_max")

	attach_to_code(obj, "PARAMETERS", """
[parmsApi addAngleSliderWithName:@"%(name)s"
                          parmId:%(param_name)s
                    defaultValue:%(default_value)f
                    parameterMin:%(param_min)f
                    parameterMax:%(param_max)f
                       parmFlags:kFxParameterFlag_DEFAULT];		
"""%v)

	attach_to_code(obj, "RETRIEVE_PARAMS", """
double %(c_name)s;
[parmsApi getFloatValue:&%(c_name)s
               fromParm:%(param_name)s
                 atTime:renderInfo.frame];
"""%v)

	attach_float_uniform(obj, v["var_name"], "%(c_name)s * %(rad_deg)s"%v)
	attach_float_uniform(obj, v["var_name"] + "_rad", v["c_name"])

def processor_point(obj, cmd, pl):
	v =  prepare_parameter(obj, pl, 5, "point")

	v["default_x"] =     float(in_list_or_default(pl, 1, 0.0))
	v["default_y"] =     float(in_list_or_default(pl, 2, 0.0))

	default_x = clamp(v["default_x"], 0, 1)
	default_y = clamp(v["default_y"], 0, 1)

	attach_to_code(obj, "PARAMETERS", ("""
[parmsApi addPointParameterWithName:@"%(name)s"
                             parmId:%(param_name)s
                           defaultX:%(default_x)f
                           defaultY:%(default_y)f
                          parmFlags:kFxParameterFlag_DEFAULT];		
""")%v)

	attach_to_code(obj, "RETRIEVE_PARAMS", """
double %(c_name)s_x;
double %(c_name)s_y;
[parmsApi getXValue:&%(c_name)s_x
             YValue:&%(c_name)s_y
           fromParm:%(param_name)s
             atTime:renderInfo.frame];
"""%v)
	
	attach_vec2_uniform(obj, v["var_name"], v["c_name"]+"_x", v["c_name"]+"_y")

def processor_intpopup(obj, cmd, pl):
	__processor_popup(obj, cmd, pl, "int", "glUniform1i", int)

def processor_floatpopup(obj, cmd, pl):		
	__processor_popup(obj, cmd, pl, "float", "glUniform1f", float)

def __processor_popup(obj, cmd, pl, c_type, uniform_set, cast_func):
	num_args = len(pl)
	if num_args % 2 == 1:
		raise Exception("Popup argument count must be even!")
	if num_args < 6:
		raise Exception("Popups need at least 6 arguments!")

	v = prepare_parameter(obj, pl, num_args, "popup")

	popup_list = []
	for i in range(2, num_args-2, 2):
		popup_list.append((str(pl[i]), cast_func(pl[i+1])))

	v["default_value"] = int(in_list_or_default(pl, 1, 0))
	if v["default_value"] < 0 or v["default_value"] >= len(popup_list):
		raise Exception("Popup default value out of range!")

	v["c_type"] = c_type
	v["uniform_set"] = uniform_set

	ns_array_string = "[NSArray arrayWithObjects:"
	val_array_string = "static const %(c_type)s %(c_name)s_values[] = {\n"%v
	for entry in popup_list:
		ns_array_string = ns_array_string + "@\"" + entry[0] + "\", "
		val_array_string = val_array_string + "   " + str(entry[1]) + ",\n"

	ns_array_string = ns_array_string + "nil]"
	val_array_string = val_array_string + "};\n"

	v["ns_array_string"] = ns_array_string
	v["val_array_string"] = val_array_string

	attach_to_scrap(obj, "uniform %(c_type)s %(var_name)s;\n"%v)

	attach_to_code(obj, "PARAMETERS", """
[parmsApi addPopupMenuWithName:@"%(name)s"
                        parmId:%(param_name)s
                  defaultValue:%(default_value)d
                   menuEntries:%(ns_array_string)s
                     parmFlags:kFxParameterFlag_DEFAULT];		
"""%v)

	attach_to_code(obj, "RETRIEVE_PARAMS", """
int %(c_name)s_index;
[parmsApi getIntValue:&%(c_name)s_index
             fromParm:%(param_name)s
               atTime:renderInfo.frame];
%(val_array_string)s
"""%v)

	attach_to_code(obj, "SET_UNIFORMS", """
%(uniform_set)s(glGetUniformLocation(_program_object, "%(var_name)s"), %(c_name)s_values[%(c_name)s_index]);
"""%v)


def processor_float(obj, cmd, pl):
	__processor_slider(obj, cmd, pl, float, "float", "double", "Float", 1, "f", "glUniform1f")

def processor_int(obj, cmd, pl):
	__processor_slider(obj, cmd, pl, int, "int", "int", "Int", 10, "d", "glUniform1i")


def __processor_slider(obj, cmd, pl, cast_func, gl_type, c_type, api_word, default_mul, f_string, uniform_set):
	v =  prepare_parameter(obj, pl, 9, gl_type)

	v["default_value"] = cast_func(in_list_or_default(pl, 1, 0.0))
	v["param_min"] =     cast_func(in_list_or_default(pl, 2, 0.0))
	v["param_max"] =     cast_func(in_list_or_default(pl, 3, 1.0 * default_mul))
	v["slider_min"] =    cast_func(in_list_or_default(pl, 4, v["param_min"]))
	v["slider_max"] =    cast_func(in_list_or_default(pl, 5, v["param_max"]))
	v["delta"] =         cast_func(in_list_or_default(pl, 6, 0.1 * default_mul))

	assure_minmax_order(v, "param_min", "param_max")
	assure_minmax_order(v, "slider_min", "slider_max")

	v["default_value"] = clamp(v["default_value"], v["param_min"], v["param_max"])
	v["slider_min"] = clamp(v["slider_min"], v["param_min"], v["param_max"])
	v["slider_max"] = clamp(v["slider_max"], v["param_min"], v["param_max"])

	v["c_type"] = c_type
	v["api_word"] = api_word
	v["uniform_set"] = uniform_set
	v["gl_type"] = gl_type

	# this is really lame ...
	v["apispace"] = " " * len(v["api_word"])

	attach_to_scrap(obj, "uniform %(gl_type)s %(var_name)s;\n"%v)

	attach_to_code(obj, "PARAMETERS", ("""
[parmsApi add%(api_word)sSliderWithName:@"%(name)s"
%(apispace)s                     parmId:%(param_name)s
%(apispace)s               defaultValue:%(default_value)""" + f_string + """
%(apispace)s               parameterMin:%(param_min)""" + f_string + """
%(apispace)s               parameterMax:%(param_max)""" + f_string + """
%(apispace)s                  sliderMin:%(slider_min)""" + f_string + """
%(apispace)s                  sliderMax:%(slider_max)""" + f_string + """
%(apispace)s                      delta:%(delta)""" + f_string + """
%(apispace)s                  parmFlags:kFxParameterFlag_DEFAULT];		
""")%v)
	
	attach_to_code(obj, "RETRIEVE_PARAMS", """
%(c_type)s %(c_name)s;
[parmsApi get%(api_word)sValue:&%(c_name)s
%(apispace)s          fromParm:%(param_name)s
%(apispace)s            atTime:renderInfo.frame];
"""%v)

	attach_to_code(obj, "SET_UNIFORMS", """
%(uniform_set)s(glGetUniformLocation(_program_object, "%(var_name)s"), %(c_name)s);
"""%v)

def objc_bool(x):
	x = x.lower()
	if x == "no" or x == "0" or x == "0.0" or x == "false":
		return "NO"
	else:
		return "YES"

def processor_toggle(obj, cmd, pl):
	v =  prepare_parameter(obj, pl, 4, "toggle")

	v["default_value"] = objc_bool(in_list_or_default(pl, 1, "YES"))

	attach_to_scrap(obj, "uniform bool %(var_name)s;\n"%v)

	attach_to_code(obj, "PARAMETERS", """
[parmsApi addToggleButtonWithName:@"%(name)s"
                           parmId:%(param_name)s
                     defaultValue:%(default_value)s
                        parmFlags:kFxParameterFlag_DEFAULT];		
"""%v)

	attach_to_code(obj, "RETRIEVE_PARAMS", """
BOOL %(c_name)s;
[parmsApi getBoolValue:&%(c_name)s
              fromParm:%(param_name)s
                atTime:renderInfo.frame];
int %(c_name)s_intValue = 0;
if(%(c_name)s) {
    %(c_name)s_intValue = 1;
}
"""%v)

	attach_to_code(obj, "SET_UNIFORMS", """
glUniform1i(glGetUniformLocation(_program_object, "%(var_name)s"), %(c_name)s_intValue);
"""%v)

def processor_image(obj, cmd, pl):
	prefix = "image"
	v =  prepare_parameter(obj, pl, 3, prefix)

	v["tex_num"] = obj["next_tex_num"]
	obj["next_tex_num"] = obj["next_tex_num"] + 1

	v["offsetx_name"] = prefix + "_" + v["var_name"] + "OffsetX"
	v["offsety_name"] = prefix + "_" + v["var_name"] + "OffsetY"

	v["cspace"] = " " * len(v["c_name"])
 
	attach_to_scrap(obj, "uniform sampler2DRect %(var_name)s;\n"%v)

	attach_to_code(obj, "PARAMETERS", """
[parmsApi addImageReferenceWithName:@"%(name)s"
                             parmId:%(param_name)s
                          parmFlags:kFxParameterFlag_DEFAULT];		
"""%v)

	attach_to_code(obj, "RETRIEVE_PARAMS", """
FxTexture *%(c_name)s = NULL;
double %(offsetx_name)s, %(offsety_name)s;
[parmsApi getTexture:&%(c_name)s
        layerOffsetX:&%(offsetx_name)s
        layerOffsetY:&%(offsety_name)s
         requestInfo:renderInfo
            fromParm:%(param_name)s
              atTime:renderInfo.frame];
"""%v)

	attach_to_code(obj, "BIND_TEXTURES", """
if(%(c_name)s != NULL) {
    glActiveTexture(GL_TEXTURE%(tex_num)d);
    [%(c_name)s bind];
}
"""%v)

	attach_to_code(obj, "SET_UNIFORMS", """
double %(c_name)s_left=0.0, %(c_name)s_right=0.0, 
       %(c_name)s_bottom=0.0, %(c_name)s_top=0.0;

if(%(c_name)s != NULL) {
    [%(c_name)s getTextureCoords:&%(c_name)s_left
%(cspace)s                 right:&%(c_name)s_right
%(cspace)s                bottom:&%(c_name)s_bottom
%(cspace)s                   top:&%(c_name)s_top];
    
    glUniform1i(glGetUniformLocation(_program_object, "%(var_name)s"), %(tex_num)d);
}
"""%v)

	attach_to_code(obj, "UNBIND_TEXTURES", """
if(%(c_name)s != NULL) {
    glActiveTexture(GL_TEXTURE%(tex_num)d);
    [%(c_name)s disable];
    glBindTexture ([%(c_name)s target], 0);
}
	"""%v)

	attach_to_code(obj, "CLEANUP", """
if(%(c_name)s != NULL) {
    [%(c_name)s release];
}
"""%v)

	attach_vec2_uniform(obj, v["var_name"] + "_dim", 
		"\n            %(c_name)s_right - %(c_name)s_left"%v, 
		"\n            %(c_name)s_top - %(c_name)s_bottom"%v)
	attach_vec2_uniform(obj, v["var_name"] + "_offset",
		"\n            " + v["offsetx_name"], v["offsety_name"])
	

# TODO: Implement Popup

PROCESSOR_LOOKUP = {
	"GLSL2FXPLUG": processor_check_version,

	"UUID": processor_set_data,
	"TYPE": processor_set_data,
	"CLASSNAME": processor_set_classname,
	"DISPLAYNAME": processor_set_data,
	"DESCRIPTION": processor_set_data,
	"GROUP": processor_set_data,
	"GROUPUUID": processor_set_data,
	"BUNDLEID": processor_set_data,
	"UUID": processor_set_data,

	"VERTEX": processor_set_vertex,
	"FRAGMENT": processor_set_fragment,

	"INPUT": processor_input,

	"FLOAT": processor_float,
	"INT": processor_int,
	"ANGLE": processor_angle,
	"TOGGLE": processor_toggle,
	"POINT": processor_point,
	"RGB": processor_rgb,
	"RGBA": processor_rgba,
	"IMAGE": processor_image,
	"FLOATPOPUP": processor_floatpopup,
	"INTPOPUP": processor_intpopup,

	"SUBGROUP": processor_subgroup,
	"ENDSUBGROUP": processor_endsubgroup,

	"TIME": processor_time,
	"CLIPTIME": processor_cliptime,
	"CLIPDURATION": processor_clipduration,
	"FPS": processor_fps,
	"SCALE": processor_scale
}

def find_first_whitespace(s):
	space_pos = s.find(" ")
	tab_pos = s.find("\t")
	nl_pos = s.find("\n")
	if space_pos < 0: space_pos = 100000 # hack
	if tab_pos < space_pos and tab_pos >= 0: space_pos = tab_pos
	if nl_pos < space_pos and nl_pos >= 0: space_pos = nl_pos
	return space_pos

def process_file(f):
	ret = {
		"current_scrap": "default_string",
		"default_string": "",
		"fragment_string": None,
		"vertex_string": None,
		"has_input_texture": False,
		"has_timing_api": False,
		"has_open_subgroup": False,
		"next_tex_num": 1,
		"param_ids": [],
		"info": {
			"UUID": None,
			"TYPE": None,
			"CLASSNAME": None,
			"DISPLAYNAME": None,
			"DESCRIPTION": None,
			"GROUP": None,
			"GROUPUUID": None,
			"BUNDLEID": None,
			"UUID": None
		},
		"code": {
			"SHADER_SOURCE": "",
			"PARAMETER_IDS": "",
			"PARAMETERS": "",
			"RETRIEVE_PARAMS": "",
			"BIND_TEXTURES": "",
			"SET_UNIFORMS": "",
			"UNBIND_TEXTURES": "",
			"CLEANUP": "",
			"VARIES_OVER_TIME": "NO",
			"REQUEST_APIS": ""
		}
	}
	num = None
	try: 
		with open(f, "r") as input_file:
			num = 0
			for line in list(input_file):
				num = num + 1
				if line[0] == "$":
					line = line[1:]
					ws_pos = find_first_whitespace(line)
					cmd = line[:ws_pos].strip()
					payload = line[ws_pos:].strip()

					if cmd in PROCESSOR_LOOKUP:
						PROCESSOR_LOOKUP[cmd](ret, cmd, parse_command_args(payload))
					else:
						raise Exception("Unknown command (" + cmd + ")")
				else:
					ret[ret["current_scrap"]] = ret[ret["current_scrap"]] + line
	except Exception as e:
		if num:
			print "--> ERROR in line " + str(num) + ": " + str(e) 
		else:
			print "--> ERROR: " + str(e)
		if DEBUG:
			raise
		return False

	if ret["has_open_subgroup"]:
		processor_endsubgroup(ret, None, None)

	generate_shader_code(ret)
	generate_paramid_code(ret)
	generate_header_code(ret)

	return ret